<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=windows-1252">
	<TITLE></TITLE>
	<META NAME="GENERATOR" CONTENT="OpenOffice.org 2.4  (Win32)">
	<META NAME="AUTHOR" CONTENT="Marty Kube">
	<META NAME="CREATED" CONTENT="20080417;17354503">
	<META NAME="CHANGEDBY" CONTENT="Marty Kube">
	<META NAME="CHANGED" CONTENT="20080417;20551375">
	<STYLE TYPE="text/css">
	<!--
		@page { size: 8.5in 11in; margin: 0.79in }
		P { margin-bottom: 0.08in }
		H1 { margin-bottom: 0.08in }
		H1.western { font-family: "Times New Roman", serif }
		H1.cjk { font-family: "Arial Unicode MS" }
		H1.ctl { font-family: "Tahoma" }
		H2 { margin-bottom: 0.08in }
		H2.western { font-family: "Albany", sans-serif; font-size: 14pt; font-style: italic }
		H2.cjk { font-family: "HG Mincho Light J"; font-size: 14pt; font-style: italic }
		H2.ctl { font-family: "Arial Unicode MS"; font-size: 14pt; font-style: italic }
	-->
	</STYLE>
</HEAD>
<BODY LANG="en-US" DIR="LTR">
<H1 CLASS="western">jBati User Guide</H1>
<P><BR><BR>
</P>
<P><FONT SIZE=4><B>V 0.1</B></FONT></P>
<P><FONT SIZE=4><B>2008-04-17</B></FONT> 
</P>
<H2 CLASS="western"><A NAME="Introduction"></A>Introduction</H2>
<P><BR><BR>
</P>
<P><A NAME="Introduction1"></A>jBati is a Object Relational Mapping
(ORM) framework for JavaScript programs. JavaScript has been used
primarily as a browser scripting language. Lately, JavaScript has
been gaining traction as a server side development language. Once
JavaScript moves to the server side, interaction with a database
becomes an important component of most applications. Developers
working on the server side use ORM frameworks to significantly
improve development speed and quality as compared to the alternative
of ad hoc persistence frameworks or SQL embedded with the application
code. jBati aims to fill the need for a JavaScript ORM solution on
the Jaxer platform. 
</P>
<P><A NAME="Introduction2"></A>jBati is targeted to the <A HREF="http://www.aptana.com/jaxer/">Jaxer</A>
platform. Jaxer is an AJAX web application development platform that
uses JavaScript on the server side. Jaxer allows development of an
entire application in JavaScript and supports database interaction in
JavaScript. 
</P>
<P>There is a spectrum of approaches in ORM frameworks. In the Java
world two contrasting examples are <A HREF="http://www.hibernate.org/">Hibernate</A>
and <A HREF="http://ibatis.apache.org/">iBATIS</A>. Both of these are
reasonable approaches; either one might be suitable depending on your
needs (here are some recommendations on <A HREF="http://f1.grp.yahoofs.com/v1/MDH8R9hmkRTGEMSze8SrVwVG5VWGtrX42M1PdTBIrDOGp6EFlLQq2eGMlwzU7Y6VrFQrHmNvJTjGCnfg_tMd6p6HmKWR07I/NovaJug%202007%20Persistence%20Choices.pdf">choosing</A>
an ORM framework). 
</P>
<P>Hibernate falls into the Traditional ORM framework camp, which are
frameworks that pretty much handle all of the object life cycle
details for you. You define object attributes and relationships, and
the framework generates SQL and often DDL, decides when object state
has changed, and generally does the right thing. The database side of
the persistence model is very much encapsulated. 
</P>
<P>iBATIS falls into the SQL mapper category. For this category of
frameworks, you define SQL statements and a mapping to objects and
object attributes and generally handles more details of the object
life cycle. 
</P>
<P>Both approaches have merit and choosing the right one depends on
the situation. SQL mappers generally work better when the application
developer has less control over the database model or when the
objects have a complex relationship to database tables. 
</P>
<P>jBati is a SQL mapper framework. If a SQL mapper is the right
choice for you, read on... 
</P>
<P>jBati is modeled on iBATIS, which is a widely used Java ORM
framework. The intent for jBati is that the configuration and API be
a direct match to iBATIS. The differences are driven by what makes
sense for the implementation language, which is Java for iBATIS and
JavaScript for jBati. Also, jBati is a newer project and will
generally have less features (at least for now). 
</P>
<P>The remainder of this document is organized around the two main
task that must be accomplished to use a SQL mapper ORM framework:
first, the configuration to specify the SQL and it's relationship to
domain objects, and second, the API that is used to access domain
objects in application code. 
</P>
<H2 CLASS="western">Background</H2>
<P>This guide will make the most sense if you are familiar with Jaxer
and iBATIS. 
</P>
<P>Setting up the framework requires that the jBati library be loaded
at the appropriate points the Jaxer page lifecycle. Check out the
Jaxer documentation on <A HREF="http://www.aptana.com/node/224">callbacks</A>
and using JavaScript libraries <A HREF="http://www.aptana.com/node/202">during
callbacks</A>. 
</P>
<P>Likewise, it might be worthwhile to take a look at the iBATIS
tutorial, or if you have a little more time, the iBATIS User Guide.
This should give you a good flavor for how to use a SQL mapping
framework and the philosophy that jBati was built on.</P>
<H2 CLASS="western">Installation</H2>
<P>Obtain the latest distribution from the project page
(<A HREF="http://code/google.com/p/jbati">http://code/google.com/p/jbati</A>).
The library is comprised of two JavaScript files, namely
jbati-client.js and jbati-server.js. The client file is intended to
be executed in the browser, while the server file is intended to be
executed on a Jaxer server.</P>
<P>A few more items before the example. The jBati API is available
here. Also, jBati is a young and fast moving project; check the
Release Notes for the availability of specific features. Current
support for databases MySql only.</P>
<P>To make good use of these files, you'll need a database, SQL, and
some JavaScript objects that you want to put together in a useful
manner. You'll have to write the configuration files which contain
the SQL and the mapping to JavaScript objects/attributes. Then,
you'll include the jBati library in you application code and use the
API to fetch and persist JavaScript objects in you database. To make
this clear, we'll start with and example and then follow up with
reference information.</P>
<H2 CLASS="western">Example</H2>
<P>The example discussed here is available in the distribution under
examples/jcs. This example is a HTML page that executes a cycle of
CRUD operations on a Person object. The attributes of the person are
first read from a HTML table and the Person object is inserted into
the database. Then the same person is read back to populate another
HTML table. Person attributes to update the in the database are read
from another table, and finally the Person is deleted from the
database. The CRUD cycle can be executed in a blocking fashion, or,
with asynchronous calls to the server. Here is a screen shot of
jbati-client-side.html in action:</P>
<P><BR><BR>
</P>
<P>[Insert image here]</P>
<P><BR><BR>
</P>
<P>The top of the jbati-client-side.html shows the pieces that are
need:</P>
<PRE>001 &lt;html&gt;
002   &lt;head&gt;
003     &lt;title&gt;jBati Examples - jBati Client Side&lt;/title&gt;
004 
005     &lt;!--
006       -- An example of jBati client side usage
007       --&gt;
008     
009     &lt;!-- load jBati server side framework --&gt;
010     &lt;script src=&quot;../../lib/jbati-server.js&quot; runat=&quot;server&quot; autoload=&quot;true&quot;&gt;&lt;/script&gt;
011     
012     &lt;!-- load jBati client side framework --&gt;
013     &lt;script src=&quot;../../lib/jbati-client.js&quot;&gt;&lt;/script&gt;
014     
015     &lt;!-- Domain objects, expose on client and server --&gt;
016     &lt;script src=&quot;user-objects.js&quot; runat=&quot;both&quot; autoload=&quot;true&quot;&gt;&lt;/script&gt;
017     
018     &lt;!-- Domain objects ORM mapping, needed only on server --&gt;
019     &lt;script src=&quot;user-object-maps.js&quot; runat=&quot;server&quot; autoload=&quot;true&quot;&gt;&lt;/script&gt;</PRE><P>
<BR><BR>
</P>
<P>On line 10, the server side of the jBati framework is imported
into the server execution context. The Jaxer attributes are important
here, both runat=&rdquo;server&rdquo; and autoload=&rdquo;true&rdquo;
are necessary. Likewise, the client side of the jBati framework,
which runs in the browser, is loaded on line 13.</P>
<P>You'll need to supply equivalent scripts for the next two included
script. The first script script defines your domain objects and the
second script tells jBati to load your configuration files which
contains SQL and the mapping to objects. 
</P>
<P>The domain objects need to be available on the client, where
you'll use them, and on the server side, where jBati will take care
of persistence operations. On line 16, the domain objects are
imported into both the client and server context with the script
attributes of runat=&rdquo;both&rdquo; and autoload=&rdquo;true&rdquo;.
Here's a listing of user-objects.js:</P>
<P><BR><BR>
</P>
<PRE>001 //
002 // User domain objects
003 //
004 (function () {
005 
006 	if(typeof Examples == 'undefined') {
007 		Examples = {};
008 	}
009 
010 	Examples.Domain = {};
011 	Examples.Domain.Person = function () {};
012 
013  
014 })();
</PRE><P>
Person is a pretty lightweight domain object. In fact, if you find
yourself declaring this type of object, you can just use the
JavaScript Object class in your object mapping. In any case, here the
domain objects are kept in a namespace object (Examples). Executing
this code is need during server callbacks to populate the global
variable Examples and thus the script attribute autoload=&rdquo;true&rdquo;
is required for this example. On the other hand, if you're not using
a namespace, the autoload attribute is not needed.</P>
<P>The next bit of scripting you need to provide tells jBati to load
your SQL and object mapping files.  On line 19 user-object-maps.js is
loaded.  Here's a listing:</P>
<PRE>001 //
002 // Load the SqlMapConfig file
003 //
004 (function () {
005 
006 	var path = Jaxer.Dir.resolvePath('../jcs/sqlMapConfig.xml');
007 	var url = Jaxer.Dir.pathToUrl(path);
008 	JBati.Server.SqlMapClientBuilder.buildSqlMapClient(url, 'ExamplesJSS');
009  
010 })();
</PRE><P>
Loading the object mapping configuration is a server side only
operation as you likely don't want to expose this information on the
Internet.  Therefore, the include script tag is run=&rdquo;server&rdquo;.
 The path to the file on line 6 is a file system path, relative in
this case, which gets resolved to a <A HREF="//./">file://</A>
protocol URL on line 7.  Line 8 invokes the jBati call to parse the
configuration file and build a client for you.</P>
<P>The jBati client is used on the browser side.  In this example,
the second parameter to buildSqlMapClient(), 'ExampleJSS' names the
client for later retrieval by JavaScript executing in the browser. 
Naming the client is optional and need only is you're using multiple
database connections.  The unnamed, or default, client uses the Jaxer
default database connection.</P>
<P>The next item we need is the configuration files.  The first file
contains a sqlMapConfig document:</P>
<PRE>001 &lt;sqlMapConfig&gt;
002 	&lt;sqlMap resource=&quot;person.xml&quot;/&gt;
003 &lt;/sqlMapConfig&gt;
</PRE><P>
This file is pretty light weight in the current version.  The only
interesting part it to load a sqlMap XML file named person.xml.  The
resource attribute is a path relative to the sqlMapConfig file.  In
future releases, this file will contain configuration specific to a
database connection (such as database type, SqlLite or MySql, and
connection credentials).  A real application would include several
sqlMap files, with files split per domain object for easier
maintenance.</P>
<P>Finally, person.xml holds the SQL and object mapping:</P>
<PRE>001 &lt;sqlMap namespace=&quot;Person&quot;&gt;
002 
003 	&lt;!-- Use scalar type as parameter and allow results to
004 	be auto-mapped results to Person object --&gt;
005 	&lt;select id=&quot;getPerson&quot; resultClass=&quot;Examples.Domain.Person&quot;&gt;
006 		SELECT 
007 		PER_ID 			as id,
008 		PER_FIRST_NAME 	as firstName,
009 		PER_LAST_NAME 	as lastName,
010 		PER_BIRTH_DATE 	as birthDate,
011 		PER_WEIGHT_KG 	as weightInKilograms,
012 		PER_HEIGHT_M		as heightInMeters
013 		FROM person 
014 		WHERE PER_ID = #value#
015 	&lt;/select&gt;
016 	
017 	&lt;!-- Use Person object properties as parameters for insert.  Each of the
018 	parameters in the #hash# symbols is a Person property.  --&gt;
019 	&lt;insert id=&quot;insertPerson&quot;&gt;
020 		INSERT INTO person (
021 			PER_ID, PER_FIRST_NAME, PER_LAST_NAME, 
022 			PER_BIRTH_DATE, PER_WEIGHT_KG, PER_HEIGHT_M
023 		) VALUES (
024 			#id#, #firstName#, #lastName#, 
025 			#birthDate#, #weightInKilograms#, #heightInMeters#
026 		)
027 	&lt;/insert&gt;
028 	
029 	&lt;!-- Use Person object properties as parameters for update. Each of the
030 	parameters in the #hash# symbols is a Person property.  --&gt;
031 	&lt;update id=&quot;updatePerson&quot;&gt;
032 		UPDATE person
033 		SET PER_FIRST_NAME = #firstName#, 
034 		PER_LAST_NAME = #lastName#, 
035 		PER_BIRTH_DATE = #birthDate#, 
036 		PER_WEIGHT_KG = #weightInKilograms#, 
037 		PER_HEIGHT_M = #heightInMeters#
038 		WHERE PER_ID = #id#
039 	&lt;/update&gt;
040 	
041 	&lt;!-- Use Person object &quot;id&quot; properties as parameters for delete. Each of the
042 	parameters in the #hash# symbols is a JavaBeans property.  --&gt;
043 	&lt;delete id=&quot;deletePerson&quot;&gt;
044 		DELETE FROM person 
045 		WHERE PER_ID = #id#
046 	&lt;/delete&gt;
047 
048 &lt;/sqlMap&gt;</PRE><P>
<BR><BR>
</P>
<P><BR><BR>
</P>
<P>Todo:  
</P>
<UL>
	<LI><P>include image</P>
	<LI><P>include DTD for XML files</P>
	<P></P>
</UL>
<P>	</P>
</BODY>
</HTML>