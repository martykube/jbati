#summary jBati Design and Architecture

= Introduction =

The design and architecture of jBati is developed here by considering:
  * How the user will interact with the framework, which is illustrated by development of two use cases.
  * Playing nice with [http://www.aptana.com/jaxer Jaxer].  The Jaxer architecture places constraint on the implementation, mostly by forcing selection of the context (browser, server, server-proxy, etc.) that sections of !JavaScript code run in.
  * Easing the user's configuration work.

The main driver is ease of use by the framework's client as represented by the use cases.  The Jaxer constraints from the second point are a given.  The fact that code can run in several different context and that there is a good sized amount of configuration data (object mapping) suggest that there are many moving parts to configure.   The jBati framework should do everything it can to make the configuration task easy. 

== Use cases ==

In order for the use cases to make sense, we need to indentify the different sections of code and the context in which the code section executes.  

The three main [http://www.aptana.com/node/275 context] in which !JavaScript code in a Jaxer application executes are:

  # Browser
  # Server
    # Initial page processing
    # [http://www.aptana.com/node/224 Callbacks]
  # Proxied functions (server side functions for which Jaxer generates proxy functions on the client)

The categories of code that are important from the framework design point of view are:

  * Client Application - the consumer of the framework, code that executes within the browser and uses jBati to create an application
  * Client Domain Objects - definition of objects used in the application for which jBati will handle persistence.
  * Client !SqlMap - configuration information supplied by the client that specifies SQL statements and the association between Client Domain Objects and SQL statements.
  * jBati API - the functions exposed to the Client Application
  * jBati Core - the internal jBati code that supports the jBati API.

The sections of code are the actors in the following use cases.  The point of the use cases is to identify the context in which each actor operates.  This level of information is sufficient to drive the detailed design/implementation of jBati.

To make the use classes more clear, the following blocks of example code will be used.  The first example is a Client Domain Object:

{{{
function Person() {}
Person.prototype = {
  id: -1,
  firstName: '',
  lastName: '',
  birthDate: new Date(),
  weightInKilograms: 0,
  heightInMeters: 0
}
}}}

The domain objects generally need to be available in both the browser and server side context.

The next example is a Client !SqlMap (using E4X):

{{{
var userSqlMap = 
<sqlMap namespace="Person">
	<select id="getPerson" resultClass="examples.domain.Person">
		SELECT 
		PER_ID 			as id,
		PER_FIRST_NAME 	as firstName,
		PER_LAST_NAME 	as lastName,
		PER_BIRTH_DATE 	as birthDate,
		PER_WEIGHT_KG 	as weightInKilograms,
		PER_HEIGHT_M		as heightInMeters
		FROM person 
		WHERE PER_ID = #value#
	</select>
</sqlMap>
}}}

The !SqlMap is used only in the Server context and is not exposed in the Browser context.  The final example shows using the jBati API to fetch a Person object with an ID of 1:

{{{
var client = jBati.getSqlMapClient();
var person = client.queryForObject('getPerson', 1);
}}}

The jBati API can be exposed in both the Browser and Server context, depending on the usage.  This is the key point of the use cases: to illustrate what support the jBati framework will need to provide when the API is exposed in these two different context.

=== Client builds proxy code - jBati Server Side (JSS) ===

The client designs a set of data access functions, implements them on the server side, and then lets Jaxer build client side proxies.  For example, the client could write a server side function for fetching a Person:

{{{
<script runat="server-proxy">
function getPerson(id) {
  var client = jBati.getSqlMapClient();
  var person = client.queryForObject('getPerson', 1);
  return person;
}
</script>
}}} 

The Browser code might look like this:

{{{
<script runat="client">
function showPerson() {
  var person = getPerson(12);
  document.getElementById('person-name').innerHTMML = person.firstName;
}
</script>
}}} 

The domain object(s) need to be available in both the Browser and Server context:

{{{
<script runat="both">
function Person() {}
Person.prototype = {
  id: -1,
  firstName: '',
  lastName: '',
  birthDate: new Date(),
  weightInKilograms: 0,
  heightInMeters: 0
}
</script>
}}}

The jBati API is used only on the server.  In all cases, the Client SqlMap and the jBati Code are Server side only objects:

{{{
<script src="client-object-map.js" runat="server"></script>
<script src="jbati.js" runat="server"></script>
<script src="jbati-core.js" runat="server"></script>
}}}

The following tables summarizes the context in which categories of code will execute in:

|| Category || Browser || Proxy || Server ||
|| Client Application|| X || || ||
|| Client Domain Objects|| X || || X ||
|| Client !SqlMap|| || || X || 
|| jBati API || || || X || 
|| jBati Core|| || || X || 


=== Client uses jBati supplied proxy - jBati Client Side (JCS) ===

In this use case, the jBati API is exposed in the Browser.

{{{
<script runat="client">
function showPerson() {
  var client = jBati.getSqlMapClient();
  var person = client.queryForObject('getPerson', 1);
  document.getElementById('person-name').innerHTMML = person.firstName;
}
</script>
}}} 

In this use case, the context for Client Domain Objects and the Client !SqlMap stays the same.  The main difference is that jBati has to now supply the server side functions that have Jaxer created proxies.

The proxy functions will have a fixed set on names and correspond to function exposed through the jBati API, client side object.  It is important to support multiple Client !SqlMaps, as the the client !SqlMaps could have different underlying database connections.

Mulitple Client !SqlMap will be supported by have each jBati !SqlMapClient correspond to a user supplied !SqlMapConfig.  For example:

{{{
<script runat="client">
  var client = jBati.getSqlMapClient('defalut');
  var otherDatabaseClient = jBati.getSqlMapClient('config-2');
</script>
}}}

Each !SqlMapClient will hold a reference to it's !SqlMapConfig and return that to the server via the proxy call.  In this example, the !SqlMapClient method queryForObject:

{{{
<script runat="client">
jBati.prototype = {
  sqlMapConfig: '',  // Name the SqlMapConfig for for this SqlMapClient instance
  showPerson: function(id, parameterObject) {
    return _jbati_proxy_queryForObject(this, id, parameterObject);
  }
}
</script>
}}}

The jBati proxy functions will be exposed in the Browser, so care will be taken to avoid name clashes.  The implementation will be along these lines:

{{{
<script runat="server-proxy">
_jbati_proxy_queryForObject(client, id, parameterObject) {
  var config  = fetchSqlMapConfig(client);
  var sql = config.getSqlStatementById(id);
  sql.bind(parameterObject);
  var resultSet = Jaxer.DB.execute(sql);
  // create use result object
  var o = objectFromResultSet(resultSet);
  return o;
}
</script>
}}}

The following tables summarizes the context in which categories of code will execute in:

|| Category || Browser || Proxy || Server ||
|| Client Application|| X || || ||
|| Client Domain Objects|| X || || X ||
|| Client !SqlMap|| || || X || 
|| jBati API || X || || X || 
|| jBati Core|| || X || X || 


== Configuration ==
